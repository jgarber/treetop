# Autogenerated from a Treetop grammar. Edits may be lost.


module Arithmetic
  include Treetop::Runtime

  def root
    @root || :expression
  end

  def _nt_expression
    run_parsing_rule(:expression) do
      i0 = index
      r1 = _nt_comparative
      if r1
        r0 = r1
      else
        r2 = _nt_additive
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  module Comparative0
    def operand_1
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def operand_2
      elements[4]
    end
  end

  def _nt_comparative
    run_parsing_rule(:comparative) do
      i0, s0 = index, []
      r1 = _nt_additive
      s0 << r1
      if r1
        r2 = _nt_space
        s0 << r2
        if r2
          r3 = _nt_equality_op
          s0 << r3
          if r3
            r4 = _nt_space
            s0 << r4
            if r4
              r5 = _nt_additive
              s0 << r5
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(BinaryOperation,input, i0...index, s0)
        r0.extend(Comparative0)
      else
        @index = i0
        r0 = nil
      end
      r0
    end
  end

  module EqualityOp0
    def apply(a, b)
      a == b
    end
  end

  def _nt_equality_op
    run_parsing_rule(:equality_op) do
      if has_terminal?('==', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
        r0.extend(EqualityOp0)
        @index += 2
      else
        terminal_parse_failure('==')
        r0 = nil
      end
      r0
    end
  end

  module Additive0
    def operand_1
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def operand_2
      elements[4]
    end
  end

  def _nt_additive
    run_parsing_rule(:additive) do
      i0 = index
      i1, s1 = index, []
      r2 = _nt_multitive
      s1 << r2
      if r2
        r3 = _nt_space
        s1 << r3
        if r3
          r4 = _nt_additive_op
          s1 << r4
          if r4
            r5 = _nt_space
            s1 << r5
            if r5
              r6 = _nt_additive
              s1 << r6
            end
          end
        end
      end
      if s1.last
        r1 = instantiate_node(BinaryOperation,input, i1...index, s1)
        r1.extend(Additive0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r7 = _nt_multitive
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  module AdditiveOp0
    def apply(a, b)
      a + b
    end
  end

  module AdditiveOp1
    def apply(a, b)
      a - b
    end
  end

  def _nt_additive_op
    run_parsing_rule(:additive_op) do
      i0 = index
      if has_terminal?('+', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        r1.extend(AdditiveOp0)
        @index += 1
      else
        terminal_parse_failure('+')
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?('-', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          r2.extend(AdditiveOp1)
          @index += 1
        else
          terminal_parse_failure('-')
          r2 = nil
        end
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  module Multitive0
    def operand_1
      elements[0]
    end

    def space1
      elements[1]
    end

    def operator
      elements[2]
    end

    def space2
      elements[3]
    end

    def operand_2
      elements[4]
    end
  end

  def _nt_multitive
    run_parsing_rule(:multitive) do
      i0 = index
      i1, s1 = index, []
      r2 = _nt_primary
      s1 << r2
      if r2
        r3 = _nt_space
        s1 << r3
        if r3
          r4 = _nt_multitive_op
          s1 << r4
          if r4
            r5 = _nt_space
            s1 << r5
            if r5
              r6 = _nt_multitive
              s1 << r6
            end
          end
        end
      end
      if s1.last
        r1 = instantiate_node(BinaryOperation,input, i1...index, s1)
        r1.extend(Multitive0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r7 = _nt_primary
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  module MultitiveOp0
    def apply(a, b)
      a * b
    end
  end

  module MultitiveOp1
    def apply(a, b)
      a / b
    end
  end

  def _nt_multitive_op
    run_parsing_rule(:multitive_op) do
      i0 = index
      if has_terminal?('*', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        r1.extend(MultitiveOp0)
        @index += 1
      else
        terminal_parse_failure('*')
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?('/', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          r2.extend(MultitiveOp1)
          @index += 1
        else
          terminal_parse_failure('/')
          r2 = nil
        end
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  module Primary0
    def space1
      elements[1]
    end

    def expression
      elements[2]
    end

    def space2
      elements[3]
    end

  end

  module Primary1
    def eval(env={})
      expression.eval(env)
    end
  end

  def _nt_primary
    run_parsing_rule(:primary) do
      i0 = index
      r1 = _nt_variable
      if r1
        r0 = r1
      else
        r2 = _nt_number
        if r2
          r0 = r2
        else
          i3, s3 = index, []
          if has_terminal?('(', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('(')
            r4 = nil
          end
          s3 << r4
          if r4
            r5 = _nt_space
            s3 << r5
            if r5
              r6 = _nt_expression
              s3 << r6
              if r6
                r7 = _nt_space
                s3 << r7
                if r7
                  if has_terminal?(')', false, index)
                    r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(')')
                    r8 = nil
                  end
                  s3 << r8
                end
              end
            end
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(Primary0)
            r3.extend(Primary1)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end
      end
      r0
    end
  end

  module Variable0
    def eval(env={})
      env[name]
    end
    
    def name
      text_value
    end
  end

  def _nt_variable
    run_parsing_rule(:variable) do
      s0, i0 = [], index
      loop do
        if has_terminal?('\G[a-z]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Variable0)
      end
      r0
    end
  end

  module Number0
  end

  module Number1
    def eval(env={})
      text_value.to_i
    end
  end

  def _nt_number
    run_parsing_rule(:number) do
      i0 = index
      i1, s1 = index, []
      if has_terminal?('\G[1-9]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(Number0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
        r0.extend(Number1)
      else
        if has_terminal?('0', false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('0')
          r5 = nil
        end
        if r5
          r0 = r5
          r0.extend(Number1)
        else
          @index = i0
          r0 = nil
        end
      end
      r0
    end
  end

  def _nt_space
    run_parsing_rule(:space) do
      s0, i0 = [], index
      loop do
        if has_terminal?(' ', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(' ')
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0
    end
  end

end

class ArithmeticParser < Treetop::Runtime::CompiledParser
  include Arithmetic
end
